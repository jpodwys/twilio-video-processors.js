{"version":3,"file":"fastBilateralFilterStage.js","sourceRoot":"","sources":["../../../../lib/processors/webgl2/pipelines/fastBilateralFilterStage.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../helpers/segmentationHelper'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport function buildFastBilateralFilterStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  inputTexture: WebGLTexture,\n  segmentationConfig: SegmentationConfig,\n  outputTexture: WebGLTexture,\n  canvas: HTMLCanvasElement\n) {\n  // NOTE(mmalavalli): This is a faster approximation of the joint bilateral filter.\n  // For a given pixel, instead of calculating the space and color weights of all\n  // the pixels within the filter kernel, which would have a complexity of O(r^2),\n  // we calculate the space and color weights of only those pixels which form two\n  // diagonal lines between the two pairs of opposite corners of the filter kernel,\n  // which would have a complexity of O(r). This improves the overall complexity\n  // of this stage from O(w x h x r^2) to O(w x h x r), where:\n  // w => width of the output video frame\n  // h => height of the output video frame\n  // r => radius of the joint bilateral filter kernel\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      return exp(-0.5 * x * x / sigma / sigma);\n    }\n\n    float calculateSpaceWeight(vec2 coord) {\n      float x = distance(v_texCoord, coord);\n      float sigma = u_sigmaTexel;\n      return gaussian(x, sigma);\n    }\n\n    float calculateColorWeight(vec2 coord) {\n      vec3 centerColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 coordColor = texture(u_inputFrame, coord).rgb;\n      float x = distance(centerColor, coordColor);\n      float sigma = u_sigmaColor;\n      return gaussian(x, sigma);\n    }\n\n    void main() {\n      vec3 centerColor = texture(u_inputFrame, v_texCoord).rgb;\n      float newVal = 0.0;\n      float totalWeight = 0.0;\n\n      vec2 leftTopCoord = vec2(v_texCoord + vec2(-u_radius, -u_radius) * u_texelSize);\n      vec2 rightTopCoord = vec2(v_texCoord + vec2(u_radius, -u_radius) * u_texelSize);\n      vec2 leftBottomCoord = vec2(v_texCoord + vec2(-u_radius, u_radius) * u_texelSize);\n      vec2 rightBottomCoord = vec2(v_texCoord + vec2(u_radius, u_radius) * u_texelSize);\n\n      float leftTopSegAlpha = texture(u_segmentationMask, leftTopCoord).a;\n      float rightTopSegAlpha = texture(u_segmentationMask, rightTopCoord).a;\n      float leftBottomSegAlpha = texture(u_segmentationMask, leftBottomCoord).a;\n      float rightBottomSegAlpha = texture(u_segmentationMask, rightBottomCoord).a;\n      float totalSegAlpha = leftTopSegAlpha + rightTopSegAlpha + leftBottomSegAlpha + rightBottomSegAlpha;\n\n      if (totalSegAlpha <= 0.0) {\n        newVal = 0.0;\n      } else if (totalSegAlpha >= 4.0) {\n        newVal = 1.0;\n      } else {\n        for (float i = 0.0; i <= u_radius - u_offset; i += u_step) {\n          vec2 shift = vec2(i, i) * u_texelSize;\n          vec2 coord = vec2(v_texCoord + shift);\n          float spaceWeight = calculateSpaceWeight(coord);\n          float colorWeight = calculateColorWeight(coord);\n          float weight = spaceWeight * colorWeight;\n          float alpha = texture(u_segmentationMask, coord).a;\n          totalWeight += weight;\n          newVal += weight * alpha;\n\n          if (i != 0.0) {\n            shift = vec2(i, -i) * u_texelSize;\n            coord = vec2(v_texCoord + shift);\n            colorWeight = calculateColorWeight(coord);\n            weight = spaceWeight * colorWeight;\n            alpha = texture(u_segmentationMask, coord).a;\n            totalWeight += weight;\n            newVal += weight * texture(u_segmentationMask, coord).a;\n            \n            shift = vec2(-i, i) * u_texelSize;\n            coord = vec2(v_texCoord + shift);\n            colorWeight = calculateColorWeight(coord);\n            weight = spaceWeight * colorWeight;\n            alpha = texture(u_segmentationMask, coord).a;\n            totalWeight += weight;\n            newVal += weight * texture(u_segmentationMask, coord).a;\n            \n            shift = vec2(-i, -i) * u_texelSize;\n            coord = vec2(v_texCoord + shift);\n            colorWeight = calculateColorWeight(coord);\n            weight = spaceWeight * colorWeight;\n            alpha = texture(u_segmentationMask, coord).a;\n            totalWeight += weight;\n            newVal += weight * texture(u_segmentationMask, coord).a;          \n          }\n        }\n        newVal /= totalWeight;\n      }\n\n      outColor = vec4(vec3(0.0), newVal);\n    }\n  `\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n  const { width: outputWidth, height: outputHeight } = canvas\n  const texelWidth = 1 / outputWidth\n  const texelHeight = 1 / outputHeight\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const segmentationMaskLocation = gl.getUniformLocation(\n    program,\n    'u_segmentationMask'\n  )\n  const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize')\n  const stepLocation = gl.getUniformLocation(program, 'u_step')\n  const radiusLocation = gl.getUniformLocation(program, 'u_radius')\n  const offsetLocation = gl.getUniformLocation(program, 'u_offset')\n  const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel')\n  const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor')\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(segmentationMaskLocation, 1)\n  gl.uniform2f(texelSizeLocation, texelWidth, texelHeight)\n\n  // Ensures default values are configured to prevent infinite\n  // loop in fragment shader\n  updateSigmaSpace(0)\n  updateSigmaColor(0)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateSigmaSpace(sigmaSpace: number) {\n    sigmaSpace *= Math.max(\n      outputWidth / segmentationWidth,\n      outputHeight / segmentationHeight\n    )\n\n    const kSparsityFactor = 0.66 // Higher is more sparse.\n    const sparsity = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor)\n    const step = sparsity\n    const radius = sigmaSpace\n    const offset = step > 1 ? step * 0.5 : 0\n    const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace\n\n    gl.useProgram(program)\n    gl.uniform1f(stepLocation, step)\n    gl.uniform1f(radiusLocation, radius)\n    gl.uniform1f(offsetLocation, offset)\n    gl.uniform1f(sigmaTexelLocation, sigmaTexel)\n  }\n\n  function updateSigmaColor(sigmaColor: number) {\n    gl.useProgram(program)\n    gl.uniform1f(sigmaColorLocation, sigmaColor)\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, updateSigmaSpace, updateSigmaColor, cleanUp }\n}\n"]}